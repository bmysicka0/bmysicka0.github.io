<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Birdsong</title>
  <!-- Favicon: musical note (♫) as SVG data URI -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-size='52' font-family='system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif'%3E%E2%99%AB%3C/text%3E%3C/svg%3E">
  <link rel="icon" type="image/svg+xml" media="(prefers-color-scheme: dark)" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-size='52' fill='%23fff' font-family='system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif'%3E%E2%99%AB%3C/text%3E%3C/svg%3E">
  <style>
    :root { color-scheme: dark light; }
    html, body { height: 100%; margin: 0; }
    body { background: #00F; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
    /* brand overlay (removed in favor of canvas-rendered warp) */
    /* kept empty in case of future reuse */
    #brand { display: none; }
    /* optional debug overlay toggle with "d" key */
    #debug { position: fixed; inset: auto 8px 8px auto; color: #FFF; font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; opacity: .55; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="debug" hidden></div>
<script>
(() => {
  const TAU = Math.PI * 2;
  const rand = (a=0, b=1) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  const qs = new URLSearchParams(location.search);
  // Scale birds with CSS pixel area; baseline 36 birds at 1280x800.
  const BASE_AREA = 1280 * 800;
  const BASE_COUNT = clamp(+qs.get('n') || 36, 1, 300);
  const computeBirdCount = () => {
    const vw = Math.max(1, innerWidth);
    const vh = Math.max(1, innerHeight);
    const area = vw * vh; // CSS pixels, not DPR-scaled
    return clamp(Math.round(BASE_COUNT * (area / BASE_AREA)), 1, 300);
  };
  const TORUS = true; // wrap world like a torus

  // Boids tuning (units are roughly px/sec and px)
  const BOIDS = {
    perception: 300,   // neighbor radius
    separation: 150,   // too-close radius
    maxSpeed: 250,     // speed clamp
    maxForce: 160,     // steering clamp (accel)
    edgeMargin: 80,    // border avoid band
    edgeForce: 1.0,    // border steering multiplier
    weights: {
      alignment: 0.1,
      cohesion: 0.1,
      separation: 1.0,
    },
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dbg = document.getElementById('debug');

  let DPR = Math.max(1, Math.min(3, self.devicePixelRatio || 1));
  let W = 0, H = 0;

  // === Brand text rendered on canvas with cylindrical warp ===
  const BRAND_TEXT = 'b i r d s o n g';
  const BRAND_FONT_FAMILY = `"Times New Roman", Times, serif`;
  let brandBuf = null; // offscreen canvas
  let brandCtx = null;
  let brandMetrics = { w: 0, h: 0, ascent: 0, descent: 0, fontPx: 0 };
  let brandTargetWidth = 0;
  let brandBendAngle = 1.3; // radians for max column (0.2..0.8 looks good)
  let brandDepthAmp = 1.3; // vertical scale boost at center (0..0.5)
  let brandY = 0;            // centerline Y for brand

  function ensureBrandBuffer() {
    if (!brandBuf) {
      brandBuf = document.createElement('canvas');
      brandCtx = brandBuf.getContext('2d');
    }

    // Target width relative to viewport (leave margins). Scale by DPR inside buffer.
    const vw = W / DPR;
    const vh = H / DPR;
    brandTargetWidth = Math.max(320, Math.min(vw * 0.82, 1400));

    // Pick a font size so the measured width ~ target width
    // Start with a guess and refine once using measured width ratio.
    let fontPx = Math.max(40, Math.min(vh * 0.18, 180));
    brandCtx.setTransform(1,0,0,1,0,0);
    brandCtx.font = `bold ${fontPx}px ${BRAND_FONT_FAMILY}`;
    let tm = brandCtx.measureText(BRAND_TEXT);
    if (tm.width > 0) {
      const scale = brandTargetWidth / tm.width;
      fontPx = Math.max(24, Math.min(220, fontPx * scale));
      brandCtx.font = `bold ${fontPx}px ${BRAND_FONT_FAMILY}`;
      tm = brandCtx.measureText(BRAND_TEXT);
    }

    // Compute buffer size at device pixels
    const textW = Math.ceil(tm.width);
    const textH = Math.ceil((tm.actualBoundingBoxAscent || fontPx * 0.8) + (tm.actualBoundingBoxDescent || fontPx * 0.2));
    const pad = Math.ceil(fontPx * 0.3);
    const bw = (textW + pad * 2);
    const bh = (textH + pad * 2);
    brandBuf.width = Math.max(2, Math.floor(bw * DPR));
    brandBuf.height = Math.max(2, Math.floor(bh * DPR));

    // Draw crisp text into buffer at DPR scale
    brandCtx.setTransform(DPR,0,0,DPR,0,0);
    brandCtx.clearRect(0, 0, bw, bh);
    brandCtx.fillStyle = '#FFF';
    brandCtx.textBaseline = 'alphabetic';
    brandCtx.textAlign = 'left';
    brandCtx.font = `bold ${fontPx}px ${BRAND_FONT_FAMILY}`;
    brandCtx.shadowColor = 'rgba(0,0,0,0.15)';
    brandCtx.shadowOffsetY = 2;
    brandCtx.shadowBlur = 0;
    const baseline = pad + (tm.actualBoundingBoxAscent || fontPx * 0.8);
    brandCtx.fillText(BRAND_TEXT, pad, baseline);

    // Cache metrics
    brandMetrics = {
      w: bw * DPR,           // buffer px
      h: bh * DPR,
      ascent: (tm.actualBoundingBoxAscent || fontPx * 0.8) * DPR,
      descent: (tm.actualBoundingBoxDescent || fontPx * 0.2) * DPR,
      fontPx: fontPx * DPR,
    };

    // Position brand vertically (canvas pixels)
    brandY = Math.floor(H * 0.5);
  }

  function resize() {
    DPR = Math.max(1, Math.min(3, self.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = false;
    ensureBrandBuffer();
  }
  addEventListener('resize', () => { resize(); resizeBirds(); });
  resize();

  // === Musical Notes Palette ===
  // Using Unicode musical symbols (not strictly ASCII) for nicer results.
  // If you *must* use ASCII-only, change GLYPHS to something like: ['o', '*', '+', '.']
  const GLYPHS = ['♩', '♪', '♫', '♬'];

  // Map local slope -> a note glyph (calmer slopes = simple notes, steeper = busier glyphs)
  function glyphForSlope(m) {
    const a = Math.abs(m);
    if (a < 0.25) return GLYPHS[0];    // ♩ quarter note
    if (a < 0.6)  return GLYPHS[1];    // ♪ eighth note
    if (a < 1.2)  return GLYPHS[2];    // ♫ beamed eighth notes
    return GLYPHS[3];                  // ♬ beamed sixteenth notes
  }

  // Bird built from y(x) = cos(1.2 * t * x) * t for x in [-2,2]
  class Bird {
    constructor(seed = Math.random()) {
      // world position (pixels, DPI scaled)
      this.x = rand(0, W);
      this.y = rand(0, H);
      this.vx = rand(-30, 60); // px/sec at DPR=1, scaled later
      this.vy = rand(-20, 20);
      this.ax = 0; // steering accel from boids
      this.ay = 0;

      // intrinsic parameters
      this.t = lerp(0.5, 1.0, Math.random()); // 0.5..1
      this.k = 1.2; // multiplier inside cos
      this.scale = rand(10, 22) * DPR; // cell size for ASCII/notes grid
      this.cols = 9; // columns sampling x in [-2,2]
      this.rows = 5; // vertical cells used to place chars

      this.phase = rand(0, TAU);
      this.flap = rand(0.4, 1.0); // animation speed factor
      this.alpha = rand(0.6, 1);

      // trail jitter so instances look distinct
      this.wobble = rand(0.6, 2.0);
    }

    update(dt) {
      // subtle flutter as a small vertical accel
      const flutter = 10 * DPR;
      const wob = Math.sin(perfNow * 0.001 * this.wobble + this.phase) * flutter;
      const ax = this.ax;
      const ay = this.ay + wob;

      // integrate velocity from accel
      this.vx += ax * dt;
      this.vy += ay * dt;

      // clamp speed
      const maxSpeed = BOIDS.maxSpeed * DPR;
      const sp = Math.hypot(this.vx, this.vy);
      if (sp > maxSpeed && sp > 0) {
        const s = maxSpeed / sp;
        this.vx *= s; this.vy *= s;
      }

      // position integration (already in px/sec)
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // toroidal wrap
      if (TORUS) {
        if (this.x < 0) this.x += W; else if (this.x >= W) this.x -= W;
        if (this.y < 0) this.y += H; else if (this.y >= H) this.y -= H;
      }

      // keep within bounds softly; exact clamping avoids drifting offscreen
      this.x = clamp(this.x, 0, W);
      this.y = clamp(this.y, 0, H);

      // subtle flapping by varying t in [0.5, 1]
      const flapAmt = 0.12; // keep within range
      this.t = clamp(this.t + Math.sin(perfNow * 0.002 * this.flap + this.phase) * flapAmt * dt, 0.5, 1.0);
    }

    draw(ctx, time) {
      // Text settings (FFF on 00F)
      const fontPx = Math.max(10, (this.scale * 0.9) | 0);
      ctx.font = `${fontPx}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#FFF';
      ctx.globalAlpha = this.alpha;

      const cols = this.cols;
      const rows = this.rows;
      const cell = this.scale;
      const halfW = ((cols - 1) / 2) * cell;
      const halfH = ((rows - 1) / 2) * cell;

      // Determine wrap draw offsets for seamless rendering near edges
      const offsX = [0];
      const offsY = [0];
      if (TORUS) {
        if (this.x < halfW) offsX.push(W);
        if (this.x > W - halfW) offsX.push(-W);
        if (this.y < halfH) offsY.push(H);
        if (this.y > H - halfH) offsY.push(-H);
      }

      for (const ox of offsX) for (const oy of offsY) {
        // sample x in [-2,2]
        for (let ci = 0; ci < cols; ci++) {
          const u = ci / (cols - 1);           // 0..1
          const x = -2 + u * 4;                // -2..2
          const px = this.x + ox + (ci - (cols-1)/2) * cell; // pixel x

          // animated phase shifts position a bit => bird "flaps"
          const tt = this.t * (1 + 0.15 * Math.sin(time * 0.0015 + this.phase));
          const y = Math.cos(this.k * tt * x) * tt; // -1..1-ish

          // derivative for slope -> glyph
          const dy = - this.k * tt * tt * Math.sin(this.k * tt * x);
          const ch = glyphForSlope(dy);

          // map y ∈ [-1,1] into row indices ~ [-2,2]
          const r = Math.round(lerp(-(rows-1)/2, (rows-1)/2, (y + 1) * 0.5));
          const py = this.y + oy + r * cell;

          ctx.fillText(ch, px, py);
        }
      }

      ctx.globalAlpha = 1;
    }
  }

  // Build flock (resizes with viewport area)
  let birds = [];
  function resizeBirds() {
    const target = computeBirdCount();
    const cur = birds.length;
    if (cur < target) {
      for (let i = 0; i < target - cur; i++) birds.push(new Bird());
    } else if (cur > target) {
      birds.length = target; // truncate extras
    }
  }
  // Initialize flock now that initial resize() has set W/H
  resizeBirds();

  let last = performance.now();
  let perfNow = last;

  function drawBentBrand() {
    if (!brandBuf) return;

    // Source in buffer pixels
    const srcW = brandMetrics.w;
    const srcH = brandMetrics.h;
    // Cylindrical mapping parameters
    const bend = brandBendAngle;
    const halfSrc = srcW / 2;
    const cx = Math.floor(W / 2);

    // Radius so that R * sin(bend) = halfSrc (in buffer pixels mapped 1:1)
    const R = halfSrc / Math.max(0.0001, Math.sin(bend));

    // Enable smoothing for warped draw only
    const prevSmooth = ctx.imageSmoothingEnabled;
    ctx.imageSmoothingEnabled = true;

    // Iterate columns and map to destination
    const sy = 0;
    const sh = srcH;
    for (let sx = 0; sx < srcW - 1; sx++) {
      const nx = (sx - halfSrc) / halfSrc; // -1..1
      const nx2 = ((sx + 1) - halfSrc) / halfSrc;
      const th0 = nx * bend;
      const th1 = nx2 * bend;
      const dx0 = cx + R * Math.sin(th0);
      const dx1 = cx + R * Math.sin(th1);
      const colW = Math.max(1, (dx1 - dx0));

      // Depth cue: make center vertically taller than edges
      const nxAbs = Math.abs(nx);
      const scaleY = 1 + brandDepthAmp * (1 - nxAbs); // 1+amp at center -> 1.0 at edges
      const dh = sh * scaleY;
      const dy = Math.floor(brandY - dh / 2);

      ctx.drawImage(brandBuf,
        sx, sy, 1, sh,                 // src 1px column
        dx0, dy, colW, dh               // dest column with mapping
      );
    }

    ctx.imageSmoothingEnabled = prevSmooth;
  }

  function frame(now) {
    perfNow = now;
    const dt = clamp((now - last) / 1000, 0, 0.033); // cap dt
    last = now;

    // Clear (00F)
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#00F';
    ctx.fillRect(0, 0, W, H);

    // mild starfield dots to accent motion (still #FFF at low alpha)
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#FFF';
    for (let i = 0; i < 40; i++) {
      const x = (Math.random() * W) | 0;
      const y = (Math.random() * H) | 0;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;

    // Boids steering pass (O(n^2))
    const perception = BOIDS.perception * DPR;
    const sepR = BOIDS.separation * DPR;
    const maxForce = BOIDS.maxForce * DPR;
    const maxSpeed = BOIDS.maxSpeed * DPR;
    const margin = BOIDS.edgeMargin * DPR;
    for (let i = 0; i < birds.length; i++) {
      const b = birds[i];
      let count = 0;
      let avgVX = 0, avgVY = 0; // alignment
      let offSumX = 0, offSumY = 0; // cohesion via avg offset (torus safe)
      let sepX = 0, sepY = 0;   // separation (away from neighbors)

      // neighbor accumulation
      for (let j = 0; j < birds.length; j++) {
        if (i === j) continue;
        const o = birds[j];
        let dx = o.x - b.x;
        let dy = o.y - b.y;
        if (TORUS) {
          if (dx > W*0.5) dx -= W; else if (dx < -W*0.5) dx += W;
          if (dy > H*0.5) dy -= H; else if (dy < -H*0.5) dy += H;
        }
        const d2 = dx*dx + dy*dy;
        if (d2 <= perception * perception) {
          count++;
          avgVX += o.vx; avgVY += o.vy;
          offSumX += dx; offSumY += dy;
          if (d2 <= sepR * sepR) {
            const d = Math.sqrt(d2) || 1;
            // push directly away (normalized)
            sepX -= dx / d;
            sepY -= dy / d;
          }
        }
      }

      let ax = 0, ay = 0;
      if (count > 0) {
        // Alignment: steer towards average velocity direction
        avgVX /= count; avgVY /= count;
        let len = Math.hypot(avgVX, avgVY) || 1;
        let desiredX = (avgVX / len) * maxSpeed;
        let desiredY = (avgVY / len) * maxSpeed;
        let steerX = desiredX - b.vx;
        let steerY = desiredY - b.vy;
        let steerLen = Math.hypot(steerX, steerY) || 1;
        if (steerLen > maxForce) { steerX = (steerX / steerLen) * maxForce; steerY = (steerY / steerLen) * maxForce; }
        ax += steerX * BOIDS.weights.alignment;
        ay += steerY * BOIDS.weights.alignment;

        // Cohesion: steer toward average offset (torus-friendly)
        let toCtrX = offSumX / count; let toCtrY = offSumY / count;
        len = Math.hypot(toCtrX, toCtrY) || 1;
        desiredX = (toCtrX / len) * maxSpeed;
        desiredY = (toCtrY / len) * maxSpeed;
        steerX = desiredX - b.vx;
        steerY = desiredY - b.vy;
        steerLen = Math.hypot(steerX, steerY) || 1;
        if (steerLen > maxForce) { steerX = (steerX / steerLen) * maxForce; steerY = (steerY / steerLen) * maxForce; }
        ax += steerX * BOIDS.weights.cohesion;
        ay += steerY * BOIDS.weights.cohesion;

        // Separation: steer away from close neighbors
        if (sepX !== 0 || sepY !== 0) {
          len = Math.hypot(sepX, sepY) || 1;
          desiredX = (sepX / len) * maxSpeed;
          desiredY = (sepY / len) * maxSpeed;
          steerX = desiredX - b.vx;
          steerY = desiredY - b.vy;
          steerLen = Math.hypot(steerX, steerY) || 1;
          if (steerLen > maxForce) { steerX = (steerX / steerLen) * maxForce; steerY = (steerY / steerLen) * maxForce; }
          ax += steerX * BOIDS.weights.separation;
          ay += steerY * BOIDS.weights.separation;
        }
      }

      // Edge behavior (disabled for TORUS)
      if (!TORUS) {
        const turn = maxForce * BOIDS.edgeForce;
        if (b.x < margin) ax += turn;
        else if (b.x > W - margin) ax -= turn;
        if (b.y < margin) ay += turn;
        else if (b.y > H - margin) ay -= turn;
      }

      b.ax = ax;
      b.ay = ay;
    }

    // Update + draw using computed steering
    for (const b of birds) { b.update(dt); b.draw(ctx, now); }

    // Draw brand warp over the scene
    drawBentBrand();

    // Debug overlay
    if (!dbg.hidden) {
      dbg.textContent = `birds: ${birds.length}\nDPR: ${DPR.toFixed(2)}\nFPS: ${(1/dt).toFixed(0)}`;
    }

    ctx.restore();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Toggle debug with "d"
  addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'd') dbg.hidden = !dbg.hidden;
  });
})();
</script>
</body>
</html>
